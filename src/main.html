<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS412 Final Project</title>
    <style>
        body { 
            margin: 0; 
            background: #111; 
            color: #ccc;
            font-family: monospace;
            padding: 20px;
        }
        canvas {
            border: 1px solid #444;
        }
        .container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
        }
        .controls {
            margin-top: 10px;
        }
        .controls label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>
<body>

<h2>CS412 Final Project - Keegan Murphy - Jagat Subedi</h2>
<p>Description / instructions <br>
temp text</p>

<div class="container">
    <div class="canvas-container">
        <canvas id="glCanvas" width="800" height="600"></canvas>
    </div>
</div>
    

<script>
    (async function() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported in this browser');
            throw new Error('WebGL 2 not supported');
        }
        
        // Ice textures: displacement and normal map)
        const iceHeightTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, iceHeightTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0,
            gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([128, 128, 255, 255]));

        const iceNormalTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, iceNormalTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0,
            gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([128, 128, 255, 255]));

        function loadIceTexture(tex, url) {
            const img = new Image();
            img.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                gl.generateMipmap(gl.TEXTURE_2D);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            };
            img.src = url;
        }

        // Load ice textures
        loadIceTexture(iceHeightTex, '../resources/Blue_Ice_001_DISP.png');
        loadIceTexture(iceNormalTex, '../resources/Blue_Ice_001_NORM.jpg');

        const vertexShaderSource = await fetch('vertex.glsl').then((res) => {
            if (!res.ok) {
                throw new Error('Failed to load vertex.glsl: ' + res.status + ' ' + res.statusText);
            }
            return res.text();
        });
        const fragmentShaderSource = await fetch('fragment.glsl').then((res) => {
            if (!res.ok) {
                throw new Error('Failed to load fragment.glsl: ' + res.status + ' ' + res.statusText);
            }
            return res.text();
        });

        let program, positionLocation, resolutionLocation, timeLocation, maxBouncesLocation, ambientStrengthLocation;
        let camPosLocation, camForwardLocation, camRightLocation, camUpLocation;
        let centerLightColorLocation, centerLightBrightnessLocation;
        let leftPaddleYLocation, rightPaddleYLocation;
        let ballPosLocation, ballRadiusLocation;
        let iceHeightMapLocation, iceNormalMapLocation;
        let iceBumpStrengthLocation, iceNormalBlendLocation;
        let vao, positionBuffer;

        // Central light UI
        let centerLightColor = [0.56, 1.0, 1.0];
        let centerLightBrightness = 0.80; // 0 -> 10

        // Paddle positions (center = 0)
        let leftPaddleY = 0.0;
        let rightPaddleY = 0.0;

        // Paddle input states (smooth movement)
        let rightPaddleUpPressed = false;
        let rightPaddleDownPressed = false;

        // Ball state
        let ballPosX = 0.0;
        let ballPosY = 0.0;
        let ballVelX = 4.0;
        let ballVelY = 2.0;
        const ballRadius = 0.12;

        // Ice floor tuning
        let iceBumpStrength = 0.05;
        let iceNormalBlend = 0.14;

        // Board data
        const boardTop = 3.25;
        const boardBottom = -3.25;
        const leftPaddleX = -4.5;
        const rightPaddleX = 4.5;
        const paddleHalfHeight = 0.5;
        const paddleHalfWidth = 0.05;
        const ballOutX = 6.0;

        let lastTime = 0;
        let lastTimeInitialized = false;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);

            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(prog));
            }

            return prog;
        }

        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        // Initialize buffers
        function initBuffers() {
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
        }

        function initShaderProgram() {
            try {
                program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
                gl.useProgram(program);
                positionLocation = gl.getAttribLocation(program, 'position');
                resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                timeLocation = gl.getUniformLocation(program, 'u_time');
                maxBouncesLocation = gl.getUniformLocation(program, 'u_maxBounces');
                ambientStrengthLocation = gl.getUniformLocation(program, 'u_ambientStrength');

                // Camera
                camPosLocation = gl.getUniformLocation(program, 'u_camPos');
                camForwardLocation = gl.getUniformLocation(program, 'u_camForward');
                camRightLocation = gl.getUniformLocation(program, 'u_camRight');
                camUpLocation = gl.getUniformLocation(program, 'u_camUp');

                // Light controls
                centerLightColorLocation = gl.getUniformLocation(program, 'u_centerLightColor');
                centerLightBrightnessLocation = gl.getUniformLocation(program, 'u_centerLightBrightness');

                // Paddle uniforms
                leftPaddleYLocation = gl.getUniformLocation(program, 'u_leftPaddleY');
                rightPaddleYLocation = gl.getUniformLocation(program, 'u_rightPaddleY');

                // Ball uniforms
                ballPosLocation = gl.getUniformLocation(program, 'u_ballPos');
                ballRadiusLocation = gl.getUniformLocation(program, 'u_ballRadius');

                // Ice texture uniforms
                iceHeightMapLocation = gl.getUniformLocation(program, 'u_iceHeightMap');
                iceNormalMapLocation = gl.getUniformLocation(program, 'u_iceNormalMap');
                iceBumpStrengthLocation = gl.getUniformLocation(program, 'u_iceBumpStrength');
                iceNormalBlendLocation = gl.getUniformLocation(program, 'u_iceNormalBlend');

                // Bind samplers to texture units 0 and 1
                if (iceHeightMapLocation) gl.uniform1i(iceHeightMapLocation, 0);
                if (iceNormalMapLocation) gl.uniform1i(iceNormalMapLocation, 1);
                if (iceBumpStrengthLocation) gl.uniform1f(iceBumpStrengthLocation, iceBumpStrength);
                if (iceNormalBlendLocation) gl.uniform1f(iceNormalBlendLocation, iceNormalBlend);

                initBuffers();
            } catch (e) {
                console.error(e);
            }
        }

        initShaderProgram();


        let maxBounces = 8;
        let ambientStrength = 0.80; // mapped 1000 -> 1)


        // Camera state (spherical coordinates)
        let camTarget = [0.0, 0.0, 0.0];
        let camRadius = 12.0;   // distance from center
        let camTheta = 0.0;    // horizontal angle (rads)
        let camPhi = 0.0;      // vertical angle (rads)

        // Vector helpers
        function normalize3(v) {
            const len = Math.hypot(v[0], v[1], v[2]) || 1.0;
            return [v[0] / len, v[1] / len, v[2] / len];
        }

        function cross3(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function length3(v) {
            return Math.hypot(v[0], v[1], v[2]);
        }

        function updateCameraUniforms() {
            if (!program) return;

            // Convert spherical to Cartesian position
            const cp = [
                camTarget[0] + camRadius * Math.cos(camPhi) * Math.sin(camTheta),
                camTarget[1] + camRadius * Math.sin(camPhi),
                camTarget[2] + camRadius * Math.cos(camPhi) * Math.cos(camTheta)
            ];

            // Forward points from camera to target
            const forward = normalize3([
                camTarget[0] - cp[0],
                camTarget[1] - cp[1],
                camTarget[2] - cp[2]
            ]);

            let worldUp = [0.0, 1.0, 0.0];
            let right = cross3(forward, worldUp);
            if (length3(right) < 1e-3) {
                // Too close to poles, switch up vector
                worldUp = [0.0, 0.0, 1.0];
                right = cross3(forward, worldUp);
            }
            right = normalize3(right);
            const up = normalize3(cross3(right, forward));

            gl.useProgram(program);
            if (camPosLocation)      gl.uniform3f(camPosLocation, cp[0], cp[1], cp[2]);
            if (camForwardLocation)  gl.uniform3f(camForwardLocation, forward[0], forward[1], forward[2]);
            if (camRightLocation)    gl.uniform3f(camRightLocation, right[0], right[1], right[2]);
            if (camUpLocation)       gl.uniform3f(camUpLocation, up[0], up[1], up[2]);
        }

        // UI Controls
        const controls = document.createElement('div');
        controls.className = 'controls';

        // Camera lock state
        let cameraLocked = false;

        // Max bounce slider
        const bouncesLabel = document.createElement('label');
        bouncesLabel.textContent = 'Max bounces ';
        const bouncesSlider = document.createElement('input');
        bouncesSlider.type = 'range';
        bouncesSlider.min = '1';
        bouncesSlider.max = '8';
        bouncesSlider.value = String(maxBounces);
        const bouncesValue = document.createElement('span');
        bouncesValue.textContent = ' ' + maxBounces;
        bouncesLabel.appendChild(bouncesSlider);
        bouncesLabel.appendChild(bouncesValue);

        // Ambient strength slider (0->1000 mapped to 0->1)
        const ambientLabel = document.createElement('label');
        ambientLabel.textContent = 'Ambient ';
        const ambientSlider = document.createElement('input');
        ambientSlider.type = 'range';
        ambientSlider.min = '0';
        ambientSlider.max = '1000';
        ambientSlider.value = String(Math.round(ambientStrength * 1000.0)); // 1000 steps
        const ambientValue = document.createElement('span');
        ambientValue.textContent = ' ' + ambientStrength.toFixed(2);
        ambientLabel.appendChild(ambientSlider);
        ambientLabel.appendChild(ambientValue);

        controls.appendChild(bouncesLabel);
        controls.appendChild(ambientLabel);

        // Camera lock toggle
        const cameraLockLabel = document.createElement('label');
        const cameraLockCheckbox = document.createElement('input');
        cameraLockCheckbox.type = 'checkbox';
        cameraLockCheckbox.checked = false;
        cameraLockLabel.appendChild(cameraLockCheckbox);
        cameraLockLabel.appendChild(document.createTextNode(' Camera lock'));
        controls.appendChild(cameraLockLabel);

        cameraLockCheckbox.addEventListener('change', () => {
            cameraLocked = cameraLockCheckbox.checked;
        });

        // Camera home button
        const cameraHomeButton = document.createElement('button');
        cameraHomeButton.textContent = 'Camera Home';
        cameraHomeButton.addEventListener('click', () => {
            camRadius = 12.0;
            camTheta = 0.0;
            camPhi = 0.0;
        });
        controls.appendChild(cameraHomeButton);

        // Light sphere color & brightness controls
        function addOrbitLightSlider(labelText, min, max, value, onChange) {
            const label = document.createElement('label');
            label.textContent = labelText + ' ';
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = String(min);
            slider.max = String(max);
            slider.value = String(value);
            const span = document.createElement('span');
            span.textContent = ' ' + value;
            slider.addEventListener('input', () => {
                const v = parseInt(slider.value, 10);
                span.textContent = ' ' + v;
                onChange(v);
            });
            label.appendChild(slider);
            label.appendChild(span);
            controls.appendChild(label);
        }

        // Center light controls
        addOrbitLightSlider('Center light R', 0, 255, 255, (v) => {
            centerLightColor[0] = v / 255.0;
        });
        addOrbitLightSlider('Center light G', 0, 255, 237, (v) => {
            centerLightColor[1] = v / 255.0;
        });
        addOrbitLightSlider('Center light B', 0, 255, 204, (v) => {
            centerLightColor[2] = v / 255.0;
        });
        addOrbitLightSlider('Center light brightness', 0, 1000, Math.round(centerLightBrightness * 100), (v) => {
            centerLightBrightness = v / 100.0; // 0->1000 to 0->10
        });

        // Attach controls
        canvas.parentElement.appendChild(controls);

        bouncesSlider.addEventListener('input', () => {
            maxBounces = parseInt(bouncesSlider.value, 10);
            bouncesValue.textContent = ' ' + maxBounces;
        });

        ambientSlider.addEventListener('input', () => {
            ambientStrength = parseInt(ambientSlider.value, 10) / 1000.0; // 0->1000 to 0->1
            ambientValue.textContent = ' ' + ambientStrength.toFixed(2);
        });

        // Mouse controls
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        //------------- Might use later?? Commented out for now ------------------

        canvas.addEventListener('mousedown', (e) => {
            if (cameraLocked) return;
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging || cameraLocked) return;
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            const rotSpeed = 0.005;
            camTheta += dx * rotSpeed;      // horizontal
            camPhi += -dy * rotSpeed;       // vertical

            const maxPhi = Math.PI / 2 - 0.1;
            const minPhi = -maxPhi;
            if (camPhi > maxPhi) camPhi = maxPhi;
            if (camPhi < minPhi) camPhi = minPhi;
        });

        // Paddle controls
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                rightPaddleUpPressed = true;
                e.preventDefault();
            } else if (e.key === 'ArrowDown') {
                rightPaddleDownPressed = true;
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp') {
                rightPaddleUpPressed = false;
                e.preventDefault();
            } else if (e.key === 'ArrowDown') {
                rightPaddleDownPressed = false;
                e.preventDefault();
            }
        });

        let startTime = Date.now();
        function render() {
            const time = (Date.now() - startTime) / 1000.0;

            if (!lastTimeInitialized) {
                lastTimeInitialized = true;
                lastTime = time;
            }
            const dt = time - lastTime;
            lastTime = time;

            // Update paddle position
            const paddleSpeed = 4.0;
            if (rightPaddleUpPressed) {
                rightPaddleY = Math.min(boardTop - paddleHalfHeight, rightPaddleY + paddleSpeed * dt);
            }
            if (rightPaddleDownPressed) {
                rightPaddleY = Math.max(boardBottom + paddleHalfHeight, rightPaddleY - paddleSpeed * dt);
            }

            // Update ball position and handle collisions
            ballPosX += ballVelX * dt;
            ballPosY += ballVelY * dt;

            // Top/bottom bounce
            if (ballPosY + ballRadius > boardTop) {
                ballPosY = boardTop - ballRadius;
                ballVelY *= -1.0;
            } else if (ballPosY - ballRadius < boardBottom) {
                ballPosY = boardBottom + ballRadius;
                ballVelY *= -1.0;
            }

            // Right paddle collision
            if (ballVelX > 0.0 &&
                ballPosX + ballRadius > rightPaddleX - paddleHalfWidth &&
                ballPosX - ballRadius < rightPaddleX + paddleHalfWidth &&
                ballPosY + ballRadius > rightPaddleY - paddleHalfHeight &&
                ballPosY - ballRadius < rightPaddleY + paddleHalfHeight) {

                ballPosX = rightPaddleX - paddleHalfWidth - ballRadius;
                ballVelX *= -1.0;
            }

            // Left paddle collision
            if (ballVelX < 0.0 &&
                ballPosX - ballRadius < leftPaddleX + paddleHalfWidth &&
                ballPosX + ballRadius > leftPaddleX - paddleHalfWidth &&
                ballPosY + ballRadius > leftPaddleY - paddleHalfHeight &&
                ballPosY - ballRadius < leftPaddleY + paddleHalfHeight) {

                ballPosX = leftPaddleX + paddleHalfWidth + ballRadius;
                ballVelX *= -1.0;
            }

            // Out-of-bounds check / reset ball
            if (ballPosX < -ballOutX || ballPosX > ballOutX) {
                ballPosX = 0.0;
                ballPosY = 0.0;
                ballVelX = 4.0;
                ballVelY = 2.0;
            }

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            // Bind ice textures
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, iceHeightTex);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, iceNormalTex);

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, time);
            gl.uniform1i(maxBouncesLocation, maxBounces);
            gl.uniform1f(ambientStrengthLocation, ambientStrength);

            // Paddle uniforms
            if (leftPaddleYLocation) gl.uniform1f(leftPaddleYLocation, leftPaddleY);
            if (rightPaddleYLocation) gl.uniform1f(rightPaddleYLocation, rightPaddleY);

            // Ball uniforms
            if (ballPosLocation) gl.uniform2f(ballPosLocation, ballPosX, ballPosY);
            if (ballRadiusLocation) gl.uniform1f(ballRadiusLocation, ballRadius);

            // Ice tuning uniforms
            if (iceBumpStrengthLocation) gl.uniform1f(iceBumpStrengthLocation, iceBumpStrength);
            if (iceNormalBlendLocation) gl.uniform1f(iceNormalBlendLocation, iceNormalBlend);

            if (centerLightColorLocation) gl.uniform3f(
                centerLightColorLocation,
                centerLightColor[0], centerLightColor[1], centerLightColor[2]
            );
            if (centerLightBrightnessLocation) gl.uniform1f(
                centerLightBrightnessLocation,
                centerLightBrightness
            );

            updateCameraUniforms();

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    })();
</script>

</body>
</html>